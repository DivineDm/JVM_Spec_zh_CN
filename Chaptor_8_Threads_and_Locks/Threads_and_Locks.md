# 第八章 线程和锁

本章介绍一些底层的基本操作(action)，这些操作将让我们能更好的看清Java虚拟机和主存是如何交互的。

## 8.1 术语和框架定义
变量在程序中随处可见，不仅包含类变量(class对象)和实例变量(class对象变量)，也包含集合中的元素等变量。变量被存储在主存(main memory)中，并被进程中的所有线程共享。对于一个线程T，他拥有的参数和变量，别的线程是无法引用到的，因此我们不用关心T拥有的参数和变量是保存在主存中，还是线程栈(working memory)中。

>**Note:** 这里对于线程参数，我理解原文想表达的是这个参数从引用关系来讲，只从属于T。因此对于主线程将一个变量v同时通过构造函数传递给T1和T2，从而形成T1和T2互相影响v的场景不是作者想表达的场景

每一个线程都有自己的线程栈，线程栈中保存线程执行use和assign操作(action)需要用到的程序变量副本，该副本是从主存中复制而来的。当一个线程执行一个程序时，线程操作这些变量副本，并不直接写主存。主存中保存所有变量的真身(master copy)，也就是说线程操作的是栈中保存的变量的分身，当然分身也可以通过一些操作覆盖真身，后面会讲到。在真身(主存中的变量)和分身(栈中的变量)的相互复制之中，需要满足一些规则。

主存中的每一个变量都有一个锁(lock)，线程可以尝试获取变量的锁。

在本章中，每一个线程可以执行如下操作use, assign, load, store, lock, unlock。主存子系统(main memeory subsystem)可以执行read, write, lock, unlock这些操作。以上的每一个操作都是原子的。

use、assign操作与线程执行引擎和线程栈紧密相关。lock和unlock操作与线程执行引擎和主存紧密相关。但是对于数据在主存和栈两个地方的来回传递，是松耦合的。当一个数据要从主存中拷贝到栈中时，两个操作必须发生：主存必须执行一个read操作，在之后的某一个时刻，对应的一个load操作必须发生在栈上。当一个数据要从栈拷贝到主存时，同样必须发生两个操作：栈上必须执行一个store操作，之后的某一个时刻，主存必须执行一个write操作。主存和栈区每一条指令执行时，都会有一个取指的运输时间(transit time，和CPU流水线结构相关)，并且不同的数据处理流(transaction)的这个时间也会不同。因此针对某一个线程对不同变量的操作，操作的初始时间构成的顺序，不同线程看到的也会有所不同。但是，不管是主存代替线程执行还是线程本身自己执行，执行的操作顺序(operation order)一定是一样的。

>**Note:** 这里我理解的是，比如对于线程T1，操作两个变量a和b，顺序是先a后b，但是操作a的变量指令取指运送时间长，后面的b反而短。当这种现象发生时，线程T1依然以为是先a后b，但是对于另一个线程T2来看，好像是b先于a发生了操作

每一个线程从程序的语义角度来看，都可以看成是由一系列的use, assign, lock, unlock构成的。在Java虚拟机规范中，线程还需要附加执行一些load, store, read和write操作，从而去满足一些条件和限制，这个后面会介绍到。如果虚拟机的实现者和程序的编写者遵循了这些限制，那么JVM规范可以保证，数据可以安全可信赖的在主存和栈中来回交换赋值。这些JVM规范是良设计的，他们被设计的足够严谨来保证数据可信赖，同时又留有余地给硬件和软件的设计者，可以利用注册、队列、缓存来充分的提供程序运行速度和吞吐量。

下面是各个操作的详细定义

* 线程执行的use操作，可以将栈中的变量传递给线程的执行引擎。每当一个线程执行一个需要用到变量去计算的虚指令(虚拟机指令)时，use操作都会被执行
* 线程执行的assign操作，可以将线程执行引擎中的变量传递给栈。每当一个线程执行一个需要复制给变量的虚指令时，assign操作都会被执行
* 主存执行的read操作，可以将主存中的变量内容发射(transmit)给线程栈，之后load操作会用到read发射出的变量值。(很多中文书这里都讲错了，read操作并没有完成主存到栈，数据复制的全过程，就像从北京到上海，read只是离开了北京而已，load才是到了上海。道理很简单，因为对于计算机系统而言，没有指令能做到主存到主存(栈也是在memory中)的转移，都需要一次主存到寄存器，再从寄存器到主存的过程)
* 线程执行的load操作，将read操作发射的变量保存到栈中
* 线程执行的store操作，将栈中的变量内容发射出去，目标是主存
* 主存执行的write操作，将store操作发射出来的变量值写入到主存
* lock操作(需要线程和主存紧密协作，同步完成)，线程尝试获得某一个锁
* unlock操作(需要线程和主存紧密协作，同步完成)，线程尝试释放某一个锁

因此，可以看出，线程和变量的交互是由一系列的use, assign, load, store构成的，主存来配合为每一个load操作执行一个read操作，为每一个store操作执行一个write操作。线程和锁的交互就是一系列的lock和unlock。所有这些对变量的操作和锁的操作，统一构成了线程展现给外界的所有行为。

## 8.2 执行顺序和一致性

## 8.3 变量的规则

## 8.4 double、long型变量的非原子性

## 8.5 锁的规则

## 8.6 锁与变量交互的规则

## 8.7 volatile变量的规则

## 8.8 带预测的store操作

## 8.9 讨论

## 8.10 例子：交换函数的多种可能性

## 8.11 例子：乱序写

## 8.12 线程

## 8.13 锁和同步

## 8.14 等待集，通知

